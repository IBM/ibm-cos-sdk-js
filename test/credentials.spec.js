const exp = require('constants');

// Generated by CoffeeScript 2.3.2
(function() {
  var AWS, helpers, validateCredentials;

  helpers = require('./helpers');

  AWS = helpers.AWS;

  validateCredentials = function(creds, key, secret, session) {
    expect(creds.accessKeyId).to.equal(key || 'akid');
    expect(creds.secretAccessKey).to.equal(secret || 'secret');
    return expect(creds.sessionToken).to.equal(session || 'session');
  };

  describe('AWS.Credentials', function() {
    describe('constructor', function() {
      it('should allow setting of credentials with keys', function() {
        var config;
        config = new AWS.Config({
          accessKeyId: 'akid',
          secretAccessKey: 'secret',
          sessionToken: 'session'
        });
        return validateCredentials(config.credentials);
      });
      it('should allow setting of credentials as object', function() {
        var creds;
        creds = {
          accessKeyId: 'akid',
          secretAccessKey: 'secret',
          sessionToken: 'session'
        };
        return validateCredentials(new AWS.Credentials(creds));
      });
      return it('defaults credentials to undefined when not passed', function() {
        var creds;
        creds = new AWS.Credentials();
        expect(creds.accessKeyId).to.equal(void 0);
        expect(creds.secretAccessKey).to.equal(void 0);
        return expect(creds.sessionToken).to.equal(void 0);
      });
    });
    describe('needsRefresh', function() {
      it('needs refresh if credentials are not set', function() {
        var creds;
        creds = new AWS.Credentials();
        expect(creds.needsRefresh()).to.equal(true);
        creds = new AWS.Credentials('akid');
        return expect(creds.needsRefresh()).to.equal(true);
      });
      it('does not need refresh if credentials are set', function() {
        var creds;
        creds = new AWS.Credentials('akid', 'secret');
        return expect(creds.needsRefresh()).to.equal(false);
      });
      it('needs refresh if creds are expired', function() {
        var creds;
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = true;
        return expect(creds.needsRefresh()).to.equal(true);
      });
      it('can be expired based on expireTime', function() {
        var creds;
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = false;
        creds.expireTime = new Date(0);
        return expect(creds.needsRefresh()).to.equal(true);
      });
      it('needs refresh if expireTime is within expiryWindow secs from now', function() {
        var creds;
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = false;
        creds.expireTime = new Date(AWS.util.date.getDate().getTime() + 1000);
        return expect(creds.needsRefresh()).to.equal(true);
      });
      return it('does not need refresh if expireTime outside expiryWindow', function() {
        var creds, ms;
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = false;
        ms = AWS.util.date.getDate().getTime() + (creds.expiryWindow + 5) * 1000;
        creds.expireTime = new Date(ms);
        return expect(creds.needsRefresh()).to.equal(false);
      });
    });
    return describe('get', function() {
      it('does not call refresh if not needsRefresh', function() {
        var creds, refresh, spy;
        spy = helpers.createSpy('done callback');
        creds = new AWS.Credentials('akid', 'secret');
        refresh = helpers.spyOn(creds, 'refresh');
        creds.get(spy);
        expect(refresh.calls.length).to.equal(0);
        expect(spy.calls.length).not.to.equal(0);
        expect(spy.calls[0].arguments[0]).not.to.exist;
        return expect(creds.expired).to.equal(false);
      });
      return it('calls refresh only if needsRefresh', function() {
        var creds, refresh, spy;
        spy = helpers.createSpy('done callback');
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = true;
        refresh = helpers.spyOn(creds, 'refresh').andCallThrough();
        creds.get(spy);
        expect(refresh.calls.length).not.to.equal(0);
        expect(spy.calls.length).not.to.equal(0);
        expect(spy.calls[0].arguments[0]).not.to.exist;
        return expect(creds.expired).to.equal(false);
      });
    });
  });

  if (AWS.util.isNode()) {
    describe('AWS.EnvironmentCredentials', function () {
      var env;
      afterEach(function () {
        process.env = env;
      });
      beforeEach(function (done) {
        env = process.env;
        process.env = {};
        return done();
      });
      describe('constructor', function () {
        it('should be able to read credentials from env with a prefix', function () {
          var creds;
          process.env.AWS_ACCESS_KEY_ID = 'akid';
          process.env.AWS_SECRET_ACCESS_KEY = 'secret';
          process.env.AWS_SESSION_TOKEN = 'session';
          creds = new AWS.EnvironmentCredentials('AWS');
          return validateCredentials(creds);
        });
        return it('should be able to read credentials from env without a prefix', function () {
          var creds;
          process.env.ACCESS_KEY_ID = 'akid';
          process.env.SECRET_ACCESS_KEY = 'secret';
          process.env.SESSION_TOKEN = 'session';
          creds = new AWS.EnvironmentCredentials();
          return validateCredentials(creds);
        });
      });
      return describe('refresh', function () {
        return it('can refresh credentials', function () {
          var creds;
          process.env.AWS_ACCESS_KEY_ID = 'akid';
          process.env.AWS_SECRET_ACCESS_KEY = 'secret';
          creds = new AWS.EnvironmentCredentials('AWS');
          expect(creds.accessKeyId).to.equal('akid');
          creds.accessKeyId = 'not_akid';
          expect(creds.accessKeyId).not.to.equal('akid');
          creds.refresh();
          return expect(creds.accessKeyId).to.equal('akid');
        });
      });
    });
    describe('AWS.FileSystemCredentials', function () {
      describe('constructor', function () {
        it('should accept filename and load credentials from root doc', function () {
          var creds, mock;
          mock = '{"accessKeyId":"akid", "secretAccessKey":"secret","sessionToken":"session"}';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.FileSystemCredentials('foo');
          return validateCredentials(creds);
        });
        return it('should accept filename and load credentials from credentials block', function () {
          var creds, mock, spy;
          mock = '{"credentials":{"accessKeyId":"akid", "secretAccessKey":"secret","sessionToken":"session"}}';
          spy = helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.FileSystemCredentials('foo');
          return validateCredentials(creds);
        });
      });
      return describe('refresh', function () {
        it('should refresh from given filename', function () {
          var creds, mock;
          mock = '{"credentials":{"accessKeyId":"RELOADED", "secretAccessKey":"RELOADED","sessionToken":"RELOADED"}}';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.FileSystemCredentials('foo');
          return validateCredentials(creds, 'RELOADED', 'RELOADED', 'RELOADED');
        });
        return it('fails if credentials are not in the file', function () {
          var mock;
          mock = '{"credentials":{}}';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          new AWS.FileSystemCredentials('foo').refresh(function (err) {
            return expect(err.message).to.equal('Credentials not set in foo');
          });
          return expect(function () {
            return new AWS.FileSystemCredentials('foo').refresh();
          }).to.throw('Credentials not set in foo');
        });
      });
    });
    describe('AWS.SharedIniFileCredentials', function () {
      var os = require('os');
      var homedir = os.homedir;
      var env;
      afterEach(function () {
        process.env = env;
      });
      beforeEach(function () {
        env = process.env;
        process.env = {};
        delete os.homedir;
      });
      afterEach(function () {
        os.homedir = homedir;
      });
      describe('constructor', function () {
        beforeEach(function () {
          var mock;
          mock = '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          return helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
        });
        it('should use os.homedir if available', function () {
          helpers.spyOn(os, 'homedir').andReturn('/foo/bar/baz');
          new AWS.SharedIniFileCredentials().refresh();
          expect(os.homedir.calls.length).to.equal(1);
          expect(AWS.util.readFileSync.calls.length).to.equal(1);
          expect(AWS.util.readFileSync.calls[0].arguments[0]).to.match(/[\/\\]foo[\/\\]bar[\/\\]baz[\/\\].aws[\/\\]credentials/);
        });
        it('should prefer $HOME to os.homedir', function () {
          process.env.HOME = '/home/user';
          helpers.spyOn(os, 'homedir').andReturn(process.env.HOME + '/foo/bar');

          new AWS.SharedIniFileCredentials();
          expect(os.homedir.calls.length).to.equal(0);
          expect(AWS.util.readFileSync.calls.length).to.equal(1);
          return expect(AWS.util.readFileSync.calls[0].arguments[0]).to
              .match(/[\/\\]home[\/\\]user[\/\\].aws[\/\\]credentials/);
        });
        it('passes an error to callback if HOME/HOMEPATH/USERPROFILE are not set', function (done) {
          new AWS.SharedIniFileCredentials({
            callback: function (err) {
              expect(err).to.be.instanceof(Error);
              expect(err.message).to.equal('Cannot load credentials, HOME path not set');
              done();
            }
          });
        });
        it('uses HOMEDRIVE\\HOMEPATH if HOME and USERPROFILE are not set', function () {
          var creds;
          process.env.HOMEDRIVE = 'd:/';
          process.env.HOMEPATH = 'homepath';
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          expect(AWS.util.readFileSync.calls.length).to.equal(1);
          return expect(AWS.util.readFileSync.calls[0]['arguments'][0]).to.match(/d:[\/\\]homepath[\/\\].aws[\/\\]credentials/);
        });
        it('uses default HOMEDRIVE of C:/', function () {
          var creds;
          process.env.HOMEPATH = 'homepath';
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          expect(AWS.util.readFileSync.calls.length).to.equal(1);
          return expect(AWS.util.readFileSync.calls[0].arguments[0]).to.match(/C:[\/\\]homepath[\/\\].aws[\/\\]credentials/);
        });
        it('uses USERPROFILE if HOME is not set', function () {
          var creds;
          process.env.USERPROFILE = '/userprofile';
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          expect(AWS.util.readFileSync.calls.length).to.equal(1);
          return expect(AWS.util.readFileSync.calls[0].arguments[0]).to.match(/[\/\\]userprofile[\/\\].aws[\/\\]credentials/);
        });
        return it('can override filename as a constructor argument', function () {
          var creds;
          creds = new AWS.SharedIniFileCredentials({
            filename: '/etc/creds'
          });
          creds.get();
          expect(AWS.util.readFileSync.calls.length).to.equal(1);
          return expect(AWS.util.readFileSync.calls[0].arguments[0]).to.equal('/etc/creds');
        });
      });
      describe('loading', function () {
        beforeEach(function () {
          process.env.HOME = '/home/user';
        });
        it('loads credentials from ~/.aws/credentials using default profile', function () {
          var creds, mock;
          mock = '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          validateCredentials(creds);
          return expect(AWS.util.readFileSync.calls[0]['arguments'][0]).to.match(/[\/\\]home[\/\\]user[\/\\].aws[\/\\]credentials/);
        });
        it('loads credentials from path defined in AWS_SHARED_CREDENTIALS_FILE if AWS_SDK_LOAD_CONFIG is set', function () {
          var creds, mock;
          process.env.AWS_SDK_LOAD_CONFIG = '1';
          process.env.AWS_SHARED_CREDENTIALS_FILE = '/path/to/aws/credentials';
          mock = '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          validateCredentials(creds);
          expect(AWS.util.readFileSync.calls[0]['arguments'][0]).to.match(/[\/\\]home[\/\\]user[\/\\].aws[\/\\]config/);
          return expect(AWS.util.readFileSync.calls[1]['arguments'][0]).to.equal(process.env.AWS_SHARED_CREDENTIALS_FILE);
        });
        it('loads credentials from ~/.aws/config if AWS_SDK_LOAD_CONFIG is set', function () {
          var creds, mock;
          process.env.AWS_SDK_LOAD_CONFIG = '1';
          mock = '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          validateCredentials(creds);
          return expect(AWS.util.readFileSync.calls[0]['arguments'][0]).to.match(/[\/\\]home[\/\\]user[\/\\].aws[\/\\]config/);
        });
        it('does not require ~/.aws/credentials if AWS_SDK_LOAD_CONFIG is set', function() {
          var creds, mock;
          process.env.AWS_SDK_LOAD_CONFIG = '1';
          mock = '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          helpers.spyOn(AWS.util, 'readFileSync').andCallFake(function(path) {
            if (path.match(/[\/\\]home[\/\\]user[\/\\].aws[\/\\]credentials/)) {
              throw new Error('ENOENT: no such file or directory');
            } else {
              return '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
            }
          });
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          validateCredentials(creds);
          return expect(AWS.util.readFileSync.calls[0]['arguments'][0]).to.match(/[\/\\]home[\/\\]user[\/\\].aws[\/\\]config/);
        });
        it('prefers credentials from ~/.aws/credentials if AWS_SDK_LOAD_CONFIG is set', function () {
          var creds;
          process.env.AWS_SDK_LOAD_CONFIG = '1';
          helpers.spyOn(AWS.util, 'readFileSync').andCallFake(function (path) {
            if (path.match(/[\/\\]home[\/\\]user[\/\\].aws[\/\\]credentials/)) {
              return '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
            } else {
              return '[default]\naws_access_key_id = AKIAIOSFODNN7EXAMPLE\naws_secret_access_key = wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY';
            }
          });
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          validateCredentials(creds);
          expect(creds.accessKeyId).to.equal('akid');
          expect(creds.secretAccessKey).to.equal('secret');
          return expect(creds.sessionToken).to.equal('session');
        });
        it('will not merge profiles across the config and credentials file', function () {
          var creds;
          process.env.AWS_SDK_LOAD_CONFIG = '1';
          helpers.spyOn(AWS.util, 'readFileSync').andCallFake(function (path) {
            if (path.match(/[\/\\]home[\/\\]user[\/\\].aws[\/\\]credentials/)) {
              return '[default]\naws_access_key_id = AKIAIOSFODNN7EXAMPLE';
            } else {
              return '[default]\naws_secret_access_key = wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY';
            }
          });
          creds = new AWS.SharedIniFileCredentials();
          return creds.get(function (err, data) {
            return expect(err).to.be.defined;
          });
        });
        it('loads credentials from ~/.aws/credentials if AWS_SDK_LOAD_CONFIG is not set', function () {
          var creds, mock;
          process.env.AWS_SHARED_CREDENTIALS_FILE = '/path/to/aws/credentials';
          mock = '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          validateCredentials(creds);
          return expect(AWS.util.readFileSync.calls[0]['arguments'][0]).to.match(/[\/\\]home[\/\\]user[\/\\].aws[\/\\]credentials/);
        });
        it('loads the default profile if AWS_PROFILE is empty', function () {
          var creds, mock;
          process.env.AWS_PROFILE = '';
          mock = '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          return validateCredentials(creds);
        });
        it('accepts a profile name parameter', function () {
          var creds, mock, spy;
          mock = '[foo]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          spy = helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials({
            profile: 'foo'
          });
          creds.get();
          return validateCredentials(creds);
        });
        it('sets profile based on ENV', function () {
          var creds, mock;
          process.env.AWS_PROFILE = 'foo';
          mock = '[foo]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          return validateCredentials(creds);
        });
        return it('accepts a loads config profiles from name parameter', function () {
          var creds, mock;
          process.env.AWS_SDK_LOAD_CONFIG = '1';
          mock = '[profile foo]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials({
            profile: 'foo'
          });
          creds.get();
          return validateCredentials(creds);
        });
      });
      describe('refresh', function () {
        var origEnv = process.env;
        beforeEach(function () {
          process.env = {};
        });
        afterEach(function () {
          process.env = origEnv;
        });
        it('should refresh from disk', function () {
          var creds, mock;
          process.env.HOME = '/home/user';
          mock = '[default]\naws_access_key_id = RELOADED\naws_secret_access_key = RELOADED\naws_session_token = RELOADED';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          creds.get();
          return validateCredentials(creds, 'RELOADED', 'RELOADED', 'RELOADED');
        });
        return it('fails if credentials are not in the file', function (done) {
          var mock = '';
          process.env.HOME = '/home/user';
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mock);
          new AWS.SharedIniFileCredentials().refresh(function (err) {
            expect(err.message).to.match(/^Profile default not found/);
            done();
          });
        });
      });
    });
    describe('AWS.SsoCredentials', function() {
      var creds, mockSSO;
      creds = null;
      beforeEach(function() {
        creds = new AWS.SsoCredentials({
          ssoClient: new AWS.SSO({ region: 'us-east-1' })
        });
        mockSSO = function(expireTime) {
          return helpers.spyOn(creds.service, 'getRoleCredentials').andCallFake(function(_, cb) {
            return cb(null, {
              roleCredentials: {
                accessKeyId: 'akid',
                secretAccessKey: 'secret',
                sessionToken: 'session',
                expiration: expireTime
              }
            });
          });
        };
        mockSSO('32503680000');
      });
      afterEach(function() {
        iniLoader.clearCachedFiles();
      });
      describe('constructor', function() {
        return it('can override filename as a constructor argument', function() {
          var creds;
          creds = new AWS.SsoCredentials({
            filename: '/etc/config'
          });
          creds.get(function(err) {
            expect(creds.filename).to.equal('/etc/config');
            done();
          });
        });
      });
      describe('loading', function() {
        beforeEach(function() {
          process.env.HOME = '/home/user';
          var mockConfig, mockToken;
          mockConfig = {
            'default': {
              'sso_start_url': 'https://d-abc123.awsapps.com/start',
              'sso_account_id': '012345678901',
              'sso_region': 'us-east-1',
              'sso_role_name': 'some-role'
            }
          };
          helpers.spyOn(AWS.util, 'getProfilesFromSharedConfig').andReturn(mockConfig);
          mockToken = JSON.stringify({
            startUrl: 'https://d-abc123.awsapps.com/start',
            region: 'us-east-1',
            accessToken: 'base64 encoded string',
            expiresAt: '32503680000'
          });
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mockToken);
        });
        afterEach(function() {
          iniLoader.clearCachedFiles();
        });
        it('loads successfully using default profile', function(done) {
          creds.refresh(function(err) {
            validateCredentials(creds);
            expect(creds.expireTime).to.not.be.null;
            done();
          });
        });
        it('loads successfully using named profile', function(done) {
          mockConfig = {
            'foo': {
              'sso_start_url': 'https://d-abc123.awsapps.com/start',
              'sso_account_id': '012345678902',
              'sso_region': 'us-east-1',
              'sso_role_name': 'some-other-role'
            }
          };
          helpers.spyOn(AWS.util, 'getProfilesFromSharedConfig').andReturn(mockConfig);
          creds.profile = 'foo';
          creds.refresh(function(err) {
            validateCredentials(creds);
            expect(creds.expireTime).to.not.be.null;
            done();
          });
        });
        it('passes httpOptions through', function(done) {
          var httpClient, spy;
          helpers.mockHttpResponse(200, {}, '<AssumeRoleResponse xmlns="https://sts.amazonaws.com/doc/2011-06-15/">\n  <AssumeRoleResult>\n    <Credentials>\n      <AccessKeyId>KEY</AccessKeyId>\n      <SecretAccessKey>SECRET</SecretAccessKey>\n      <SessionToken>TOKEN</SessionToken>\n      <Expiration>1970-01-01T00:00:00.000Z</Expiration>\n    </Credentials>\n  </AssumeRoleResult>\n</AssumeRoleResponse>');
          creds = new AWS.SsoCredentials({
            httpOptions: {
              connectTimeout: 2000,
              proxy: 'https://foo.bar',
              timeout: 2000,
            }
          });
          httpClient = AWS.HttpClient.getInstance();
          spy = helpers.spyOn(httpClient, 'handleRequest').andCallThrough();
          return creds.refresh(function(err) {
            expect(spy.calls.length).to.equal(1);
            expect(spy.calls[0].arguments[1].connectTimeout).to.equal(2000);
            expect(spy.calls[0].arguments[1].proxy).to.equal('https://foo.bar');
            expect(spy.calls[0].arguments[1].timeout).to.equal(2000);
            return done();
          });
        });
        it('loads successfully while changing region and endpoint', function(done) {
          expect(creds.service.config.region).to.equal('us-east-1');
          expect(creds.service.config.endpoint).to.equal('portal.sso.us-east-1.amazonaws.com');
          mockConfig = {
            'default': {
              'sso_start_url': 'https://d-abc123.awsapps.com/start',
              'sso_account_id': '012345678902',
              'sso_region': 'cn-north-1',
              'sso_role_name': 'some-role'
            }
          };
          helpers.spyOn(AWS.util, 'getProfilesFromSharedConfig').andReturn(mockConfig);
          mockToken = JSON.stringify({
            startUrl: 'https://d-abc123.awsapps.com/start',
            region: 'cn-north-1',
            accessToken: 'base64 encoded string',
            expiresAt: '32503680000'
          });
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mockToken);
          creds.refresh(function(err) {
            expect(creds.service.config.region).to.equal('cn-north-1');
            expect(creds.service.config.endpoint).to.equal('portal.sso.cn-north-1.amazonaws.com.cn');
            done();
          });
        });
        it('throws error if sso config is invalid', function(done) {
          mockConfig = {
            'default': {
              'output': 'json',
              'region': 'us-east-1'
            }
          };
          helpers.spyOn(AWS.util, 'getProfilesFromSharedConfig').andReturn(mockConfig);
          creds.refresh(function(err) {
            expect(err.message).to.match(/^Profile default does not have valid SSO credentials/);
            expect(creds.accessKeyId).to.be.undefined;
            done();
          });
        });
        it('throws error if sso credentials are expired', function(done) {
          mockConfig = {
            'default': {
              'sso_start_url': 'https://d-abc123.awsapps.com/start',
              'sso_account_id': '012345678902',
              'sso_region': 'us-east-1',
              'sso_role_name': 'some-role'
            }
          };
          helpers.spyOn(AWS.util, 'getProfilesFromSharedConfig').andReturn(mockConfig);
          mockToken = JSON.stringify({
            startUrl: 'https://d-abc123.awsapps.com/start',
            region: 'us-east-1',
            accessToken: 'base64 encoded string',
            expiresAt: '2021-03-11'
          });
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(mockToken);
          creds.refresh(function(err) {
            expect(err.message).to.match(/^The SSO session associated with this profile has expired. To refresh this SSO session run aws sso login with the corresponding profile./);
            expect(creds.accessKeyId).to.be.undefined;
            done();
          });
        });
        it('throws error if no cached credentials found', function(done) {
          helpers.spyOn(AWS.util, 'readFileSync').andReturn('');
          creds.refresh(function(err) {
            expect(err.message).to.match(/^Cached credentials not found under default profile. Please make sure you log in with aws sso login first/);
            expect(creds.accessKeyId).to.be.undefined;
            done();
          });
        });
        it('throws error if cached credentials are missing required fields', function(done) {
          invalidToken = JSON.stringify({
            startUrl: 'https://d-abc123.awsapps.com/start',
            region: 'us-east-1',
            // missing accessToken
            expiresAt: '9999999-01-01'
          });
          helpers.spyOn(AWS.util, 'readFileSync').andReturn(invalidToken);
          creds.refresh(function(err) {
            expect(err.message).to.match(/^Cached credentials are missing required properties. Try running aws sso login./);
            expect(creds.accessKeyId).to.be.undefined;
            done();
          });
        });
        it('throws error if sso client returns no data', function(done) {
          helpers.spyOn(creds.service, 'getRoleCredentials').andCallFake(function(_, cb) {
            return cb(null, {});
          });
          creds.refresh(function(err) {
            expect(err.message).to.eql('Please log in using "aws sso login"');
            expect(creds.accessKeyId).to.be.undefined;
            done();
          });
        });
        it('throws error if sso client returns data with missing properties', function(done) {
          helpers.spyOn(creds.service, 'getRoleCredentials').andCallFake(function(_, cb) {
            return cb(null, {
              roleCredentials: {
                accessKeyId: 'accessKeyId',
                // missing secretAccessKey,
                sessionToken: 'sessionToken',
                expiration: 'expiration',
              },
            });
          });
          creds.refresh(function(err) {
            expect(err.message).to.eql('SSO returns an invalid temporary credential.');
            expect(creds.accessKeyId).to.be.undefined;
            done();
          });
        });
        return it('throws error if sso client returns an error', function(done) {
          var mockErr;
          mockErr = 'foo Error';
          helpers.spyOn(creds.service, 'getRoleCredentials').andCallFake(function(_, cb) {
            return cb(new Error(mockErr), null);
          });
          creds.refresh(function(err) {
            expect(err.message).to.eql(mockErr);
            expect(creds.accessKeyId).to.be.undefined;
            done();
          });
        });
      });
      describe('refresh', function() {
        var origEnv = process.env;
        beforeEach(function() {
          process.env = {};
        });
        afterEach(function() {
          process.env = origEnv;
          iniLoader.clearCachedFiles();
        });
}).call(this);
